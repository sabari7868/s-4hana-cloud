'use strict';

const _ = require('lodash');
const request = require('../utils/request-utils');
const passportUtils = require('../passport/utils');
const sessionExt = require('../utils/session-ext');
// eslint-disable-next-line no-undef
const tracer = require('../utils/logger').getTracer(__filename);
const X_FRAME_OPTIONS = 'x-frame-options';
const CSP_HEADER_NAME = 'Content-Security-Policy';

module.exports = async function additionalHeaders(req, res, next) {
  let routerConfig = req.routerConfig;

  let additionalHeaders = routerConfig.additionalHeaders.slice();

  additionalHeaders = modifyAdditionalHeadersFromResponseHeaders(req,additionalHeaders);

  if (routerConfig.sendXFrameOptions) {
    let xFrameHeader = _.find(additionalHeaders, function searchXFrame(header) { return !!header[X_FRAME_OPTIONS]; });
    if (!xFrameHeader) {
      res.setHeader(X_FRAME_OPTIONS, 'SAMEORIGIN');
    }
  }
  additionalHeaders.forEach(function addAdditionalHeader(header) {
    _.forEach(header, function setHeader(value, name) {
      let currentValue = res.getHeader(name);
      if (currentValue === undefined) {
        res.setHeader(name, value);
      } else if (Array.isArray(currentValue)) {
        currentValue.push(value);
      } else { // string
        res.setHeader(name, [currentValue, value]);
      }
    });
  });
  try {
    await module.exports.getCSPFrameAncestorsFromSubaccount(req, res, routerConfig);
  } catch (err){
    return next(err);
  }
  next();
};

function getLandscapeDomain(cfApiUrl) {
  let url = new URL(cfApiUrl);
  let parts = url.hostname.split('.');
  parts.shift(); // remove 'api'
  parts.shift(); // remove 'cf'
  return parts.join('.');
}

module.exports.getCSPFrameAncestorsFromSubaccount = async function getCSPFrameAncestorsFromSubaccount(req, res, routerConfig) {
  if (routerConfig.enableCSPheaders) {
    let subdomain = passportUtils.getTenantInfo(req).tenant;
    if (!subdomain) {
      return;
    }
    const landscapeDomain = getLandscapeDomain(JSON.parse(process.env.VCAP_APPLICATION).cf_api);
    if (!landscapeDomain) {
      return;
    }
    const apiURL = `https://api.authentication.${landscapeDomain}/sap/rest/authorization/v2/securitySettings/public?subdomain=${subdomain}`;
    // Check if cspHeaders are in the session
    if (req.session && req.session.cspHeaders) {
      res.setHeader(CSP_HEADER_NAME, req.session.cspHeaders);
    } else {
      let result = await request.axiosRequest('get',{url: apiURL});
      if (result.error || result.response.statusCode !== 200){
        throw new Error('Failed to fetch allowed domains from xsuaa ' + result.error
            + (result.response && result.response.statusCode ? `response status ${result.response.statusCode}` : ''));
      }
      const resultBody = result.body && JSON.parse(result.body);
      if (resultBody){
        const cspHeaders = `frame-ancestors ${resultBody.iframeDomains};`;
        res.setHeader(CSP_HEADER_NAME, cspHeaders);
        // Store cspHeaders in the session
        if (req.session) {
          sessionExt.update(req.session, function(session) {
            session.cspHeaders = cspHeaders;
          });
        }
      }
    }
  }
};

function modifyAdditionalHeadersFromResponseHeaders(req, additionalHeaders) {
  let foundIndex;

  if (!req.routerConfig.appConfig.responseHeaders){
    return additionalHeaders;
  }

  req.routerConfig.appConfig.responseHeaders.forEach(function (responseHeader) {
    foundIndex = -1;

    for (let i = 0; i < additionalHeaders.length; i++) {
      if (additionalHeaders[i].hasOwnProperty(responseHeader.name)) {
        foundIndex = i;
        break;
      }
    }

    if (foundIndex > -1) {
      additionalHeaders[foundIndex] = {
        [responseHeader.name]: responseHeader.value
      };
      tracer.debug('found response header name %s in additional headers, so update response header value %s instead of previous value', responseHeader.name, responseHeader.value);
    }
    else {
      additionalHeaders.push({
        [responseHeader.name]: responseHeader.value
      });
    }

  });

  return additionalHeaders;
}